package dataserver;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.TooManyListenersException;

import javax.comm.CommPortIdentifier;
import javax.comm.NoSuchPortException;
import javax.comm.PortInUseException;
import javax.comm.SerialPort;
import javax.comm.SerialPortEvent;
import javax.comm.SerialPortEventListener;
import javax.comm.UnsupportedCommOperationException;

import com.sun.comm.Win32Driver;

public class SerialManager extends Thread implements SerialPortEventListener {
	private CommPortIdentifier portId;
	private SerialPort serialPort;
	private BufferedReader fluxLecture;
	private BufferedWriter fluxEcriture;
	private boolean running;

	/**
	 * Constructeur qui récupère l'identifiant du port et lance l'ouverture.
	 */
	public SerialManager(String port) {
		//initialisation du driver
		//A MODIFIER POUR LINUX
		Win32Driver w32Driver = new Win32Driver();
		w32Driver.initialize();
		
		//récupération de l'identifiant du port
		try {
			portId = CommPortIdentifier.getPortIdentifier(port);
		} catch (NoSuchPortException e) { }
		
		//ouverture du port
		try {
			serialPort = (SerialPort) portId.open("ModeEvenement", 2000);
		} catch (PortInUseException e) { }
		
		//récupération du flux
		try {
			fluxLecture =
				new BufferedReader(
					new InputStreamReader(serialPort.getInputStream()));
		} catch (IOException e) { }
		
		try {
			fluxEcriture = 
					new BufferedWriter(
							new OutputStreamWriter(serialPort.getOutputStream()));
		}catch (IOException e) { }
		
		//ajout du listener
		try {
			serialPort.addEventListener(this);
		} catch (TooManyListenersException e) { }
		
		//paramétrage du port
		serialPort.notifyOnDataAvailable(true);
		try {
			serialPort.setSerialPortParams(
				9600,
				SerialPort.DATABITS_7,
				SerialPort.STOPBITS_1,
				SerialPort.PARITY_EVEN);
		} catch (UnsupportedCommOperationException e) {
		}
		System.out.println("port ouvert, attente de lecture");
	}
	
	@Override
	public void run() {
		running = true;
		while (running) {
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
			}
		}
		//fermeture du flux et port
		try {
			fluxLecture.close();
		} catch (IOException e) {
		}
		serialPort.close();
	}
	
	/**
	 * Méthode de gestion des événements.
	 */
	public void serialEvent(SerialPortEvent event) {
		//gestion des événements sur le port :
		//on ne fait rien sauf quand les données sont disponibles
		switch (event.getEventType()) {
			case SerialPortEvent.BI :
			case SerialPortEvent.OE :
			case SerialPortEvent.FE :
			case SerialPortEvent.PE :
			case SerialPortEvent.CD :
			case SerialPortEvent.CTS :
			case SerialPortEvent.DSR :
			case SerialPortEvent.RI :
			case SerialPortEvent.OUTPUT_BUFFER_EMPTY :
				break;
			case SerialPortEvent.DATA_AVAILABLE :
				String codeBarre = new String(); 
				try {
					//lecture du buffer et affichage
					codeBarre = (String) fluxLecture.readLine();
					
					//LANCEMENT DE LA REQUETE
					
					
					if(codeBarre.equals("0000000001FAB")){


						//SORTIE
						fluxEcriture.write("OPEN");
					}
					
					
					
				} catch (IOException e) {
				}
				break;
		}
	}
	
	public void stopThread() {
		running = false;
	}
}
